{"ast":null,"code":"// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i; // node names which could be successful controls\n\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i; // Matches bracket notation.\n\nvar brackets = /(\\[[^\\[\\]]*\\])/g; // serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\n\nfunction serialize(form, options) {\n  if (typeof options != 'object') {\n    options = {\n      hash: !!options\n    };\n  } else if (options.hash === undefined) {\n    options.hash = true;\n  }\n\n  var result = options.hash ? {} : '';\n  var serializer = options.serializer || (options.hash ? hash_serializer : str_serialize);\n  var elements = form && form.elements ? form.elements : []; //Object store each radio and set if it's empty or not\n\n  var radio_store = Object.create(null);\n\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i]; // ingore disabled fields\n\n    if (!options.disabled && element.disabled || !element.name) {\n      continue;\n    } // ignore anyhting that is not considered a success field\n\n\n    if (!k_r_success_contrls.test(element.nodeName) || k_r_submitter.test(element.type)) {\n      continue;\n    }\n\n    var key = element.name;\n    var val = element.value; // we can't just use element.value for checkboxes cause some browsers lie to us\n    // they say \"on\" for value when the box isn't checked\n\n    if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n      val = undefined;\n    } // If we want empty elements\n\n\n    if (options.empty) {\n      // for checkbox\n      if (element.type === 'checkbox' && !element.checked) {\n        val = '';\n      } // for radio\n\n\n      if (element.type === 'radio') {\n        if (!radio_store[element.name] && !element.checked) {\n          radio_store[element.name] = false;\n        } else if (element.checked) {\n          radio_store[element.name] = true;\n        }\n      } // if options empty is true, continue only if its radio\n\n\n      if (val == undefined && element.type == 'radio') {\n        continue;\n      }\n    } else {\n      // value-less fields are ignored unless options.empty is true\n      if (!val) {\n        continue;\n      }\n    } // multi select boxes\n\n\n    if (element.type === 'select-multiple') {\n      val = [];\n      var selectOptions = element.options;\n      var isSelectedOptions = false;\n\n      for (var j = 0; j < selectOptions.length; ++j) {\n        var option = selectOptions[j];\n        var allowedEmpty = options.empty && !option.value;\n        var hasValue = option.value || allowedEmpty;\n\n        if (option.selected && hasValue) {\n          isSelectedOptions = true; // If using a hash serializer be sure to add the\n          // correct notation for an array in the multi-select\n          // context. Here the name attribute on the select element\n          // might be missing the trailing bracket pair. Both names\n          // \"foo\" and \"foo[]\" should be arrays.\n\n          if (options.hash && key.slice(key.length - 2) !== '[]') {\n            result = serializer(result, key + '[]', option.value);\n          } else {\n            result = serializer(result, key, option.value);\n          }\n        }\n      } // Serialize if no selected options and options.empty is true\n\n\n      if (!isSelectedOptions && options.empty) {\n        result = serializer(result, key, '');\n      }\n\n      continue;\n    }\n\n    result = serializer(result, key, val);\n  } // Check for all empty radio buttons and serialize them with key=\"\"\n\n\n  if (options.empty) {\n    for (var key in radio_store) {\n      if (!radio_store[key]) {\n        result = serializer(result, key, '');\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction parse_keys(string) {\n  var keys = [];\n  var prefix = /^([^\\[\\]]*)/;\n  var children = new RegExp(brackets);\n  var match = prefix.exec(string);\n\n  if (match[1]) {\n    keys.push(match[1]);\n  }\n\n  while ((match = children.exec(string)) !== null) {\n    keys.push(match[1]);\n  }\n\n  return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n  if (keys.length === 0) {\n    result = value;\n    return result;\n  }\n\n  var key = keys.shift();\n  var between = key.match(/^\\[(.+?)\\]$/);\n\n  if (key === '[]') {\n    result = result || [];\n\n    if (Array.isArray(result)) {\n      result.push(hash_assign(null, keys, value));\n    } else {\n      // This might be the result of bad name attributes like \"[][foo]\",\n      // in this case the original `result` object will already be\n      // assigned to an object literal. Rather than coerce the object to\n      // an array, or cause an exception the attribute \"_values\" is\n      // assigned as an array.\n      result._values = result._values || [];\n\n      result._values.push(hash_assign(null, keys, value));\n    }\n\n    return result;\n  } // Key is an attribute name and can be assigned directly.\n\n\n  if (!between) {\n    result[key] = hash_assign(result[key], keys, value);\n  } else {\n    var string = between[1]; // +var converts the variable into a number\n    // better than parseInt because it doesn't truncate away trailing\n    // letters and actually fails if whole thing is not a number\n\n    var index = +string; // If the characters between the brackets is not a number it is an\n    // attribute name and can be assigned directly.\n\n    if (isNaN(index)) {\n      result = result || {};\n      result[string] = hash_assign(result[string], keys, value);\n    } else {\n      result = result || [];\n      result[index] = hash_assign(result[index], keys, value);\n    }\n  }\n\n  return result;\n} // Object/hash encoding serializer.\n\n\nfunction hash_serializer(result, key, value) {\n  var matches = key.match(brackets); // Has brackets? Use the recursive assignment function to walk the keys,\n  // construct any missing objects in the result tree and make the assignment\n  // at the end of the chain.\n\n  if (matches) {\n    var keys = parse_keys(key);\n    hash_assign(result, keys, value);\n  } else {\n    // Non bracket notation can make assignments directly.\n    var existing = result[key]; // If the value has been assigned already (for instance when a radio and\n    // a checkbox have the same name attribute) convert the previous value\n    // into an array before pushing into it.\n    //\n    // NOTE: If this requirement were removed all hash creation and\n    // assignment could go through `hash_assign`.\n\n    if (existing) {\n      if (!Array.isArray(existing)) {\n        result[key] = [existing];\n      }\n\n      result[key].push(value);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result;\n} // urlform encoding serializer\n\n\nfunction str_serialize(result, key, value) {\n  // encode newlines as \\r\\n cause the html spec says so\n  value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n  value = encodeURIComponent(value); // spaces should be '+' rather than '%20'.\n\n  value = value.replace(/%20/g, '+');\n  return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;","map":{"version":3,"names":["k_r_submitter","k_r_success_contrls","brackets","serialize","form","options","hash","undefined","result","serializer","hash_serializer","str_serialize","elements","radio_store","Object","create","i","length","element","disabled","name","test","nodeName","type","key","val","value","checked","empty","selectOptions","isSelectedOptions","j","option","allowedEmpty","hasValue","selected","slice","parse_keys","string","keys","prefix","children","RegExp","match","exec","push","hash_assign","shift","between","Array","isArray","_values","index","isNaN","matches","existing","replace","encodeURIComponent","module","exports"],"sources":["/home/osroot/Desktop/host/contacts-front/node_modules/form-serialize/index.js"],"sourcesContent":["// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n    if (typeof options != 'object') {\n        options = { hash: !!options };\n    }\n    else if (options.hash === undefined) {\n        options.hash = true;\n    }\n\n    var result = (options.hash) ? {} : '';\n    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);\n\n    var elements = form && form.elements ? form.elements : [];\n\n    //Object store each radio and set if it's empty or not\n    var radio_store = Object.create(null);\n\n    for (var i=0 ; i<elements.length ; ++i) {\n        var element = elements[i];\n\n        // ingore disabled fields\n        if ((!options.disabled && element.disabled) || !element.name) {\n            continue;\n        }\n        // ignore anyhting that is not considered a success field\n        if (!k_r_success_contrls.test(element.nodeName) ||\n            k_r_submitter.test(element.type)) {\n            continue;\n        }\n\n        var key = element.name;\n        var val = element.value;\n\n        // we can't just use element.value for checkboxes cause some browsers lie to us\n        // they say \"on\" for value when the box isn't checked\n        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n            val = undefined;\n        }\n\n        // If we want empty elements\n        if (options.empty) {\n            // for checkbox\n            if (element.type === 'checkbox' && !element.checked) {\n                val = '';\n            }\n\n            // for radio\n            if (element.type === 'radio') {\n                if (!radio_store[element.name] && !element.checked) {\n                    radio_store[element.name] = false;\n                }\n                else if (element.checked) {\n                    radio_store[element.name] = true;\n                }\n            }\n\n            // if options empty is true, continue only if its radio\n            if (val == undefined && element.type == 'radio') {\n                continue;\n            }\n        }\n        else {\n            // value-less fields are ignored unless options.empty is true\n            if (!val) {\n                continue;\n            }\n        }\n\n        // multi select boxes\n        if (element.type === 'select-multiple') {\n            val = [];\n\n            var selectOptions = element.options;\n            var isSelectedOptions = false;\n            for (var j=0 ; j<selectOptions.length ; ++j) {\n                var option = selectOptions[j];\n                var allowedEmpty = options.empty && !option.value;\n                var hasValue = (option.value || allowedEmpty);\n                if (option.selected && hasValue) {\n                    isSelectedOptions = true;\n\n                    // If using a hash serializer be sure to add the\n                    // correct notation for an array in the multi-select\n                    // context. Here the name attribute on the select element\n                    // might be missing the trailing bracket pair. Both names\n                    // \"foo\" and \"foo[]\" should be arrays.\n                    if (options.hash && key.slice(key.length - 2) !== '[]') {\n                        result = serializer(result, key + '[]', option.value);\n                    }\n                    else {\n                        result = serializer(result, key, option.value);\n                    }\n                }\n            }\n\n            // Serialize if no selected options and options.empty is true\n            if (!isSelectedOptions && options.empty) {\n                result = serializer(result, key, '');\n            }\n\n            continue;\n        }\n\n        result = serializer(result, key, val);\n    }\n\n    // Check for all empty radio buttons and serialize them with key=\"\"\n    if (options.empty) {\n        for (var key in radio_store) {\n            if (!radio_store[key]) {\n                result = serializer(result, key, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction parse_keys(string) {\n    var keys = [];\n    var prefix = /^([^\\[\\]]*)/;\n    var children = new RegExp(brackets);\n    var match = prefix.exec(string);\n\n    if (match[1]) {\n        keys.push(match[1]);\n    }\n\n    while ((match = children.exec(string)) !== null) {\n        keys.push(match[1]);\n    }\n\n    return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n    if (keys.length === 0) {\n        result = value;\n        return result;\n    }\n\n    var key = keys.shift();\n    var between = key.match(/^\\[(.+?)\\]$/);\n\n    if (key === '[]') {\n        result = result || [];\n\n        if (Array.isArray(result)) {\n            result.push(hash_assign(null, keys, value));\n        }\n        else {\n            // This might be the result of bad name attributes like \"[][foo]\",\n            // in this case the original `result` object will already be\n            // assigned to an object literal. Rather than coerce the object to\n            // an array, or cause an exception the attribute \"_values\" is\n            // assigned as an array.\n            result._values = result._values || [];\n            result._values.push(hash_assign(null, keys, value));\n        }\n\n        return result;\n    }\n\n    // Key is an attribute name and can be assigned directly.\n    if (!between) {\n        result[key] = hash_assign(result[key], keys, value);\n    }\n    else {\n        var string = between[1];\n        // +var converts the variable into a number\n        // better than parseInt because it doesn't truncate away trailing\n        // letters and actually fails if whole thing is not a number\n        var index = +string;\n\n        // If the characters between the brackets is not a number it is an\n        // attribute name and can be assigned directly.\n        if (isNaN(index)) {\n            result = result || {};\n            result[string] = hash_assign(result[string], keys, value);\n        }\n        else {\n            result = result || [];\n            result[index] = hash_assign(result[index], keys, value);\n        }\n    }\n\n    return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n    var matches = key.match(brackets);\n\n    // Has brackets? Use the recursive assignment function to walk the keys,\n    // construct any missing objects in the result tree and make the assignment\n    // at the end of the chain.\n    if (matches) {\n        var keys = parse_keys(key);\n        hash_assign(result, keys, value);\n    }\n    else {\n        // Non bracket notation can make assignments directly.\n        var existing = result[key];\n\n        // If the value has been assigned already (for instance when a radio and\n        // a checkbox have the same name attribute) convert the previous value\n        // into an array before pushing into it.\n        //\n        // NOTE: If this requirement were removed all hash creation and\n        // assignment could go through `hash_assign`.\n        if (existing) {\n            if (!Array.isArray(existing)) {\n                result[key] = [ existing ];\n            }\n\n            result[key].push(value);\n        }\n        else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n    // encode newlines as \\r\\n cause the html spec says so\n    value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n    value = encodeURIComponent(value);\n\n    // spaces should be '+' rather than '%20'.\n    value = value.replace(/%20/g, '+');\n    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}